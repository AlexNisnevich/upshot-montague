package sfdc

import metadata._
import sqlkit._
import sqlkit.RelativeDateRangeValue
import sqlkit.BinaryPredicate
import util.Logging
import scala.reflect.runtime.universe.TypeTag
import scala.reflect.runtime.universe.typeOf

/**
 * When we have a SqlKit that is SOQL-formatted (because it was generated by SoqlParser), use this to generate SOQL.
 * We should probably cherry-pick some of the overrides from SqlToSoqlGenerator.
 */
class SoqlGenerator extends BaseSqlGenerator with Logging {
  override protected def generateSqlPart[T: TypeTag](a: T): String = a match {
    case s@Select(from, joins, projs, where, orderBy, limit, groupBy, having, blobSql) =>
      "SELECT " + projs.map(generateSqlPart(_)).mkString(", ") + "\n" +
        "FROM " + generateSqlPart(from) + s.soqlJoins.map(generateSqlPart(_)).mkString("") + "\n" +
        s.sqlJoins.map(generateSqlPart(_)).convertOrElse(_.mkString("\n") + "\n", "")  +
        where.map(generateSqlPart(_)).map(_ + "\n").getOrElse("") +
        orderBy.convertOrElse("ORDER BY " + generateSqlPart(_) + "\n", "") +
        groupBy.convertOrElse("GROUP BY " + generateSqlPart(_) + "\n", "") +
        limit.map("LIMIT " + _ + "\n").getOrElse("") +
        blobSql.getOrElse("")
    case a: Aliased[Proj @unchecked] if typeOf[T] =:= typeOf[Aliased[Proj]] => a.fold(generateSqlPart(_), _ + " " + _)
    case SoqlJoin(Aliased(name, alias)) => ", " + name + alias.map(" " + _).getOrElse("")
    case _ => super.generateSqlPart(a)
  }
}

/**
 * This SOQL generator takes a SQL-formated SqlKit (generated by the parser),
 * then transforms it to SOQL-formatted SqlKit,
 * then generates the SOQL.
 * This is awfully hairy and we should remove it in the future.
 * @param md
 */
class SqlToSoqlGenerator(md: Metadata) extends BaseSqlGenerator with Logging {
  override protected def generateSqlPart[T: TypeTag](a: T): String = a match {
    case mainSelect@Select(from, joins, projs, where, orderBy, limit, groupBy, having, blobSql) =>
      val newMainSelect = rewriteForAllChildJoins(mainSelect)
      "SELECT " + newMainSelect.projs.map(generateSqlPart(_)).mkString(", ") + "\n" +
      // We punt on SoqlJoins here
        "FROM " + generateSqlPart(from) +
        newMainSelect.sqlJoins.map(generateLookupJoin(newMainSelect, _)).convertOrElse(", " + _.mkString(", "), "")  + "\n" +
        newMainSelect.where.map(generateSqlPart(_)).map(_ + "\n").getOrElse("") +
        orderBy.convertOrElse("ORDER BY " + generateSqlPart(_) + "\n", "") +
        groupBy.convertOrElse("GROUP BY " + generateSqlPart(_) + "\n", "") +
        limit.map("LIMIT " + _ + "\n").getOrElse("") +
        blobSql.getOrElse("")
    case a: Aliased[Proj @unchecked] if typeOf[T] =:= typeOf[Aliased[Proj]] => a.fold(_.getSql, _ + " " + _)
    // List because we could have: "name is joe or thom or greg"
    // @todo: handle list of items, instead of just the head
    // "LIKE" doesn't work with empty string
    case bp@BinaryPredicate(column, "like", List(LiteralValue(""))) => generateSqlPart(bp.copy(op = "="))
    // "NOT LIKE" has a stupid syntax
    case bp@BinaryPredicate(column, "not like", values) => "NOT " + generateSqlPart(bp.copy(op = "like"))
    case BinaryPredicate(column, op, List((RelativeDateRangeValue(gran, n)))) =>
      // Based upon http://www.salesforce.com/us/developer/docs/officetoolkit/Content/sforce_api_calls_soql_select_dateformats.htm
      (gran, n) match {
        case (Day, -1) => s"$column $op YESTERDAY"
        case (Day, 0) => s"$column $op TODAY"
        case (Day, 1) => s"$column $op TOMORROW"
        case (_, -1) => s"$column $op LAST_${gran.uppercaseSoql}"
        case (_, 0) => s"$column $op THIS_${gran.uppercaseSoql}"
        case (_, 1) => s"$column $op NEXT_${gran.uppercaseSoql}"
        case (_, _) =>
          if (n < 0) { s"$column $op LAST_N_${gran.uppercaseSoql}S:${-n}" }
          else { s"$column $op NEXT_N_${gran.uppercaseSoql}S:$n" }
        case _ => {
          logger.error(s"Could not create BinaryPredicate for column $column $op $gran $n")
          ""
        }
      }
    case BinaryPredicate(column, op, List((AbsoluteDatePeriodValue(Year, yearValue)))) =>
      s"CALENDAR_YEAR($column) $op ${yearValue.toString}"
    case _ => super.generateSqlPart(a)
  }

  private[this] def rewriteForAllChildJoins(mainSelect: Select) = {
    val rootFrom = mainSelect.from.t.asInstanceOf[BaseRelation].from
    val sqlJoins = mainSelect.sqlJoins
    // We punt on SoqlJoins here
    val newMainSelect = sqlJoins.foldLeft[Select](mainSelect)((newMainSelect: Select, join) => rewriteForChildJoin(rootFrom, join, newMainSelect))
    newMainSelect
  }

  /**
   * Remove elements (projections and filters) from the main select that are being moved to the child selects.
   * See comments to rewriteForJoin() for more explanation.
   */
  private[this] def clipMainSelect(mainSelect: Select, childJoinSelect: Select): Select = {
    val allChildJoinProjs = childJoinSelect.projs.toSet
    val nonChildJoinProjs = mainSelect.projs.filter(!allChildJoinProjs.contains(_))

    val nonChildJoinWhere = mainSelect.where match {
      case Some(Filter(AndFilter(conds))) =>
        if (childJoinSelect.where.isDefined) {
          val allChildJoinFilters = childJoinSelect.where.map(_.root.asInstanceOf[AndFilter].children).getOrElse(Nil).toSet
          val nonChildJoinFilters = conds.filter(!allChildJoinFilters.contains(_))
          if (!nonChildJoinFilters.isEmpty) {
            Some(Filter(AndFilter(nonChildJoinFilters)))
          } else {
            None
          }
        } else {
          mainSelect.where
        }
      case None => None
      case _ => throw new NotImplementedError
    }

    mainSelect.copy(projs = nonChildJoinProjs, where = nonChildJoinWhere)
  }

  /**
   * Append some filters to a select, creating a new select
   */
  private[this] def addFilters(select: Select, filtersToAdd: Seq[FilterExpr]): Select = {
    val newWhere = select.where match {
      case None => Some(Filter(AndFilter(filtersToAdd.toList)))
      case Some(Filter(AndFilter(conds))) => Some(Filter(AndFilter(conds ++ filtersToAdd.toList)))
      case Some(Filter(filterExpr)) => Some(Filter(AndFilter(List(filterExpr) ++ filtersToAdd.toList)))
    }
    select.copy(where = newWhere)
  }

  /**
   * Generate a FilterExpr with a semi-join IN condition for a given inner join
   *
   * Suppose mainSelect = SELECT FROM account a
   * Suppose childJoinSelect = SELECT FROM a.contacts c
   *
   * Then this generates a filter expression suitable for appending to the mainSelect that looks like:
   * a.id IN (SELECT c.accountid FROM contact c)
   *
   * Which can be appended to the WHERE clause of mainSelect
   *
   * @param mainSelect the main select statement (for the parent)
   * @param childJoin the child join
   * @param childFrom the from table for the child.  Note that this differs from the FROM clause in the childJoinSelect
   *                  because the childJoinSelect references the child relationship name
   */
  private[this] def getSemiJoinForInnerJoin(mainSelect: Select, childJoin: SfdcChildJoin, childFrom: Aliased[Relation]): FilterExpr = {
    val childForeignKey = childJoin.childRelationship.childForeignKeyColumn.columnExpr
    val childAlias = childJoin.childJoinSelect.from.alias.map(_ + ".").getOrElse("")
    val subquery = childJoin.childJoinSelect.copy(from = childFrom, projs = Seq(Aliased(Proj(childAlias + childForeignKey))))
    val parentPrimaryKey = childJoin.parentRelation dotted childJoin.childRelationship.table.primaryKey.columnExpr
    val semiJoin = FilterPred(parentPrimaryKey + " IN (" + generateSqlPart(subquery).trim + ")")
    semiJoin
  }

  /**
   * Rewrite a SOQL select with a SQL-92-style join into a SOQL-style join
   *
   * @param rootFrom the from clause in the main select
   * @param join the join to rewrite
   * @param mainSelect the main select
   */
  private[this] def rewriteForChildJoin(rootFrom: String, join: SqlJoin, mainSelect: Select): Select = {
    /**
     * Inner join.  The SQL-style inner join contains the projections and filters inline with the main select, for example:
     * SELECT a.name, c.name
     * FROM account a
     * JOIN contact c
     * WHERE c.accountid = a.id
     * AND a.industry = 'BioTech'
     * AND c.name = 'Tom'
     *
     * We want to get to:
     * SELECT a.name, (SELECT c.name FROM a.Contacts c WHERE c.name = 'Tom')
     * FROM account a
     * WHERE a.industry = 'BioTech'
     * AND a.id IN (SELECT c.accountid FROM contact c WHERE c.name = 'Tom')
     *
     * We refer to the original SELECT statement as the "mainSelect".  We refer to the "(SELECT..)" inside the main
     * select's projections clause as the "sub-select".  And we refer to the "a.id IN (SELECT... " as the
     * semi-join.
     *
     * Two big things need to happen:  (1) Collecting together the projections and where conditions for the
     * sub-select and *moving* them all to a sub-select.  And (2) Generating the semi-join.
     *
     * The first big thing breaks down into 3 steps:
     * (1a) Generate the sub-select by copying over the projections and filters
     * (1b) Add the sub-select to the main select's projections clause
     * (1c) Remove the copied projections and filters from the main select
     */
    // Step 1a:  Generate the sub-select by copying over the projections and filters
    // Rename the from table to the dotted child relationship name
    generateJoinInfo(join, mainSelect).collect({ case j: SfdcChildJoin => j }) map { sfdcChildJoin =>
      val childJoinSelect = sfdcChildJoin.childJoinSelect
      // Step 1b:  Add the sub-select to the main select's projections clause
      var newMainSelect =
        if (sfdcChildJoin.parentRelation == mainSelect.from) {
          mainSelect.copy(projs = mainSelect.projs :+ Aliased(Proj("(" + generateSqlPart(childJoinSelect).trim + ")")))
        } else {
          // Don't create the sub-select if the join is not off of the root table (i.e. the join is off of a lookup of the main table instead)
          // For example, "tasks related to accounts with account team members", then the root is tasks, while account
          // team member is off of account
          mainSelect
        }
      // Step 1c:  Remove the copied projections and filters from the main select.
      newMainSelect = clipMainSelect(newMainSelect, childJoinSelect)
      if (join.joinType == InnerJoin) {
        // Step 2:  Generate the semi-join
        newMainSelect = addFilters(newMainSelect, Seq(getSemiJoinForInnerJoin(newMainSelect, sfdcChildJoin, join.relation)))
      }
      newMainSelect = removeSqlJoin(newMainSelect, join)
      newMainSelect
    } getOrElse mainSelect
  }

  def generateAllJoinInfos(mainSelect: Select) = {
    // We punt on SoqlJoins here
    mainSelect.sqlJoins.flatMap(generateJoinInfo(_, mainSelect))
  }

  /**
   * For a child join, generate the child join sub-select.  Also return some relevant metadata information to allow
   * callers to do something intelligent with this join.
   *
   * See the example above to see the sub-select this generates.
   */
  // Step 1a:  Generate the sub-select by copying over the projections and filters
  // Rename the from table to the dotted child relationship name
  private[this] def generateJoinInfo(join: SqlJoin, mainSelect: Select): Option[SfdcJoin] = {
    join match {
      case SqlJoin(rel@Aliased(from@BaseRelation(fromExpr), alias), joinExpr, InnerJoin) =>
        findParentRelation(joinExpr, mainSelect, alias.get) flatMap { parent =>
          val parentFrom = parent.t.asInstanceOf[BaseRelation].from
          val parentTable = md.findTable(_.fromExpr == parentFrom).get
          // @bug need to use the joinExpr here too
          val childRelationshipOpt = parentTable.childRelationships.find(_.childTable.fromExpr == fromExpr)
          childRelationshipOpt map { childRelationship =>
          // Step 1a:  Generate the sub-select by copying over the projections and filters
          // Rename the from table to the dotted child relationship name
            val childJoinSelect =
              Select(Aliased(BaseRelation(childRelationship.name), alias), Nil,
                SqlToSoqlGenerator.getProjsByTableAlias(mainSelect.projs, alias.get), mainSelect.where.flatMap(getFiltersByTableAlias(_, alias.get)))
            SfdcChildJoin(parent, childRelationship, childJoinSelect)
          } orElse {
            val rootFrom = mainSelect.from.t.asInstanceOf[BaseRelation].from
            val sourceTable = md.findTable(_.fromExpr == rootFrom).get
            val targetTable = md.findTable(_.fromExpr == fromExpr).get
            parseJoinColumn(joinExpr, mainSelect.from.alias.get) flatMap { sourceColumnName =>
              val foreignkey = sourceTable.getColumn(sourceColumnName).get
              foreignkey.get[ForeignKeyInfo] flatMap { foreignKeyInfo =>
                assert(foreignKeyInfo.targetTable == targetTable)
                foreignKeyInfo.sfdcLookupRelationshipName map { lookupRelationshipName =>
                  SfdcLookupJoin(alias.get, foreignkey)
                  //mainSelect.from.alias.get + "." + lookupRelationshipName + " " + join.relation.alias.get
                }
              }
            }
          }
        }
      case SqlJoin(rel@Aliased(select@Select(Aliased(BaseRelation(fromExpr), fromAlias), _, _, _, _, _, _, _, _), alias), joinExpr, LeftOuterJoin) =>
        /**
         * Outer join. This is much easier than inner join because the SQL-92-style syntax already uses a sub-select.
         * So we don't need to copy things, and we don't need to generate a semi-join.
         */
        findParentRelation(joinExpr, mainSelect, alias.get) flatMap { parent =>
          val parentFrom = parent.t.asInstanceOf[BaseRelation].from
          val parentTable = md.findTable(_.fromExpr == parentFrom).get
          val childRelationshipOpt = parentTable.childRelationships.find(_.childTable.fromExpr == fromExpr)
          childRelationshipOpt map { childRelationship =>
            val childJoinSelect = select.copy(from = Aliased(BaseRelation(childRelationship.name), fromAlias))
            SfdcChildJoin(parent, childRelationship, childJoinSelect)
          }
        }
      // otherwise throw a MatchError because we shouldn't be seeing anything else
    }
  }

  /**
   * Given a joinExpr like "atm.AccountId = a.Id" and a table alias e.g. "atm"
   * find the Relation for the parent "a" in the select statement.  This could be the root of the select
   * or it could be another joined table.
   */
  private[this] def findParentRelation(joinExpr: String, select: Select, childTableAlias: String) = {
    val parentAlias = parseJoinColumn(joinExpr).find(_._1 != childTableAlias).get._1
    select.findTableByAlias(parentAlias)
  }

  /**
   * Generate the SOQL bit for a lookup join
   *
   * Given a mainSelect like:
   *
   * SELECT c.Name, a.Name
   * FROM contact c
   * JOIN account a ON a.id = c.accountid
   *
   * Then we generate a string like "c.Account a" to be used in an extended FROM clause like:
   *
   * SELECT c.Name, a.Name
   * FROM contact c, c.Account a
   *
   * Note that we must translate "c.accountid" to "c.Account".  In this case "Account" is the "lookup relationship
   * name" from the sfdc metadata.
   *
   * @todo change the semantics of SqlStringGenerator.generateSql() to return an Option, with None
   *       meaning the generation failed.  (or Either)
   *
   * @throws IllegalArgumentException if we fail to translate the given join into an appropriate bit of SQL
   */
  private[this] def generateLookupJoin(mainSelect: Select, join: SqlJoin): String = {
    generateJoinInfo(join, mainSelect) flatMap {
      case lookup: SfdcLookupJoin =>
        lookup.foreignKeyInfo.sfdcLookupRelationshipName map { lookupRelationshipName =>
          mainSelect.from.alias.get + "." + lookupRelationshipName + " " + join.relation.alias.get
        }
      case _ => None // this would indicate some kind of programming error
    } getOrElse {
      throw new IllegalArgumentException("Couldn't generate SOQL for a lookup join: select = " + mainSelect.toString + ", join = " + join.toString)
    }
  }

  /**
   * Given an expression like "a.id = c.accountid" and a searchTableAlias say "c".
   * Return the column for that table alias i.e. "accountid".
   *
   * @param joinExpr a join condition
   * @param searchTableAlias a table alias to search for
   * @return the column of that table alias in the join expression
   */
  private[this] def parseJoinColumn(joinExpr: String, searchTableAlias: String): Option[String] = {
    parseJoinColumn(joinExpr).find(_._1 == searchTableAlias).map(_._2)
  }

  /**
   * Given an expression like "a.id = c.accountid" return all the column
   * references
   *
   * @param joinExpr a join condition
   * @return a list of (tableAlias, columnName) pairs
   */
  private[this] def parseJoinColumn(joinExpr: String): Iterable[(String, String)] = {
    val joinColumns = joinExpr.split('=')
    val joinTableAndColumns =
      for(joinColumn <- joinColumns) yield {
        val Array(tableAlias, columnName) = joinColumn.trim.split('.')
        (tableAlias, columnName)
      }
    joinTableAndColumns
  }

  private[this] def removeSqlJoin(select: Select, join: SqlJoin): Select = {
    select.copy(joins = select.sqlJoins.filterNot(_ == join))
  }

  private[this] def getFiltersByTableAlias(where: Filter, tableAlias: String): Option[Filter] = {
    getFiltersByTableAliasRecursive(where.root, tableAlias) map { Filter(_) }
  }

  private[this] def getFiltersByTableAliasRecursive(filterExpr: FilterExpr, tableAlias: String): Option[FilterExpr] = {
    filterExpr match {
      case AndFilter(conds) =>
        val newConds = conds flatMap { getFiltersByTableAliasRecursive(_, tableAlias) }
        if (!newConds.isEmpty) {
          Some(AndFilter(newConds))
        } else {
          None
        }
      case FilterPred(expr) =>
        if (expr.contains(tableAlias + ".")) {
          Some(filterExpr)
        } else {
          None
        }
      case BinaryPredicate(column, _, _) =>
        if (column.contains(tableAlias + ".")) {
          Some(filterExpr)
        } else {
          None
        }
    }
  }

}

object SqlToSoqlGenerator {
  def getProjsByTableAlias(projs: Seq[Aliased[Proj]], tableAlias: String) = {
    projs.filter(_.t.getSql.startsWith(tableAlias + "."))
  }
}

/**
 * Metadata about the joins we are generating.
 */
sealed trait SfdcJoin

/**
 * A child join like "accounts with opportunities", in that case the child join is Opportunties being joined in via
 * Opportunity.AccountId aka the child relationship Account.Opportunities.  If we have SOQL like
 *      select from account a, a.opportunities o
 * Then parentRelation is the "account a", childRelationship = Account.Opportunities, and childJoinSelect is
 * "select ... from opportunity o where o....."
 */
case class SfdcChildJoin(parentRelation: Aliased[Relation], childRelationship: ChildRelationship, childJoinSelect: Select) extends SfdcJoin
case class SfdcLookupJoin(alias: String, sourceForeignKey: Column) extends SfdcJoin {
  def foreignKeyInfo = sourceForeignKey.get[ForeignKeyInfo].get
}
